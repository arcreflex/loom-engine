# Persistence (FileSystemStore)

Filesystem store as the canonical persistence layer.

## Layout

The data directory (default `~/.loom/`) contains:

```
~/.loom/
├── config.toml              # Configuration file
├── loom.log                 # Application logs
├── roots.json               # Registry of all conversation roots
└── <rootId>/
    └── nodes/
        └── node-<n>.json    # Individual node files
```

### File Purposes

- **roots.json**: Index of all conversation roots with basic metadata
- **nodes/*.json**: Individual conversation nodes with messages and relationships

## ID Strategy

### Root IDs
- **Generation**: Generated by IdCache, ensuring non-collision
- **Format**: `root-<n>` (monotonic numbering)
- **Scope**: Globally unique across all data directories

### Node IDs
- **Generation**: Generated by IdCache with collision checking against disk
- **Format**: `<rootId>/node-<n>` (monotonic numbering within root)
- **Scope**: Globally unique, includes root prefix

### ID Generation Characteristics
- **Monotonic**: IDs are monotonic per process and collision-checked against disk
- **Collision avoidance**: IdCache ensures no collision with existing files on disk
- **Human readable**: IDs contain enough context for debugging and root association

## Caching

### NodeStructure Cache
**Purpose**: Avoid filesystem reads for tree navigation

**Cache contents**:
- Parent/child relationships
- Node existence flags
- Root topology
- **Excludes**: Message content, metadata

**Cache structure**: Single in-memory array across all roots, invalidated on save/delete

### Cache Invalidation
Cache invalidation occurs on:
- **saveNode**: New nodes added or modified
- **deleteNode**: Nodes removed from tree
- **saveRootInfo**: Root creation or updates
Matches current FileSystemStore implementation.

### Cache Expectations
- **Performance**: Tree navigation without filesystem access
- **Consistency**: Cache reflects current filesystem state
- **Lazy population**: Cache built on-demand, not pre-loaded

## Consistency

### Write Ordering
**Direct writes**: Files written directly with fs.writeFile (no temp-file/rename sequence)
**Cache invalidation**: NodeStructure cache invalidated after writes
**No transactional guarantees**: No multi-file transaction or locking mechanisms

### Acceptable Failure Modes
- **Stale cache**: Cache may be outdated after external modifications
- **Index inconsistency**: roots.json may briefly lag behind node creation
- **No crash recovery**: No temporary file cleanup needed

**Recovery behavior**:
- Ignore temporary files on startup
- Rebuild cache from filesystem on inconsistency detection
- Validate index against actual node files

### Atomicity Assumptions
- **Single file**: Each node write is atomic (relies on filesystem atomicity of single-file writes)
- **Multiple files**: No multi-file transaction or locking
- **Single process**: This store is intended for single-process use. Multi-process access may cause conflicts
- **No file locking**: Relies on single-process assumption; suggest DB store for multi-user/multi-process scenarios

## Migration Considerations

### Schema Versioning
- **Current approach**: No explicit schema version in files
- **Future evolution**: Version field may be added to support migration
- **Backward compatibility**: Prefer additive changes over breaking changes

### Data Migration Strategy
- **migrate.cjs**: One-off script for legacy data format conversion
- **In-place migration**: Modify existing files rather than copying
- **Validation**: Verify migrated data integrity

### Upgrade Path
1. Backup existing data directory
2. Run migration script
3. Validate converted data
4. Remove backup after successful operation

## Replaceability

### Store Interface Expectations
Alternative store implementations must provide:

**Core operations**:
- Create/read/update/delete for roots and nodes
- Atomic write guarantees within single entities
- Parent/child relationship management

**Performance characteristics**:
- Fast tree traversal for navigation
- Efficient bulk operations for large conversations
- NodeStructure cache support

**Consistency guarantees**:
- Read-after-write consistency within single process
- Cache invalidation hooks
- Conflict detection for concurrent access

### Implementation Flexibility
Store implementations may:
- Use different ID generation strategies
- Provide stronger consistency guarantees
- Optimize for different access patterns
- Support multi-user scenarios

### Migration Between Stores
- **Export/import**: Standardized data format for store migration
- **Incremental sync**: Partial migration for large datasets
- **Validation**: Ensure data integrity across store types

## Non-goals

This specification does not cover:
- Method signatures and API contracts (see code)
- Specific error handling implementations
- Performance benchmarks or SLA requirements
- Multi-process locking mechanisms
- Backup and recovery procedures